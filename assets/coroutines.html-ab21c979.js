import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as c,c as p,d as s,e as n,b as l,a}from"./app-2bf5d4a1.js";const i={},u=a(`<h1 id="协程" tabindex="-1"><a class="header-anchor" href="#协程" aria-hidden="true">#</a> 协程</h1><h2 id="kotlin协程与c-task的区别" tabindex="-1"><a class="header-anchor" href="#kotlin协程与c-task的区别" aria-hidden="true">#</a> kotlin协程与C#Task的区别</h2><p>Kotlin 中的协程（Coroutines）和 C# 中的 Task 在异步编程方面有一些区别。以下是它们的主要区别：</p><ol><li><p>语法和使用方式：协程在 Kotlin 中是语言级别的特性，通过 <code>suspend</code> 关键字标记挂起函数，并使用协程构建器（如 <code>launch</code>、<code>async</code> 等）创建协程。而 C# 的 Task 是基于 .NET 框架的异步编程模型，使用 <code>async</code> 和 <code>await</code> 关键字来定义和操作异步任务。</p></li><li><p>调度器和线程模型：Kotlin 的协程可以使用不同的调度器来控制协程的执行线程，例如 <code>Dispatchers.Default</code>、<code>Dispatchers.IO</code>、<code>Dispatchers.Main</code> 等。这使得在不同的上下文中执行协程变得更加灵活。而 C# 的 Task 默认使用线程池来执行异步任务，但可以通过配置 <code>TaskScheduler</code> 来更改任务的调度行为。</p></li><li><p>取消和异常处理：Kotlin 的协程提供了内置的取消机制，可以通过 <code>CoroutineScope</code> 中的 <code>cancel</code> 函数取消协程的执行，并通过协程上下文中的异常处理器来处理异常。而在 C# 中，通过 <code>CancellationToken</code> 来取消任务的执行，并通过 <code>try-catch</code> 块来捕获和处理异常。</p></li><li><p>异步流和数据流：Kotlin 的协程提供了对异步流的原生支持，可以使用 <code>Flow</code> 类型来处理连续的异步数据流。这使得在处理大量数据或持续产生数据的情况下更加方便。C# 中的 Task 并没有提供类似的原生支持，但可以通过其他库（如 Reactive Extensions）来实现类似的功能。</p></li></ol><p>总体而言，Kotlin 的协程更加灵活和表达性强，提供了更多的控制权和异步编程的工具。C# 中的 Task 则是基于 .NET 框架的异步编程模型的一部分，更加成熟和广泛使用，但在某些情况下可能需要借助其他库来实现类似于协程的功能。</p><h2 id="协程的使用" tabindex="-1"><a class="header-anchor" href="#协程的使用" aria-hidden="true">#</a> 协程的使用</h2><p>协程是 Kotlin 中用于异步编程的强大工具。下面是使用协程的基本步骤：</p><ol><li>添加协程库依赖：首先，在你的 Kotlin 项目中添加协程库的依赖。在 Gradle 中，可以使用以下方式添加依赖：</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>dependencies <span class="token punctuation">{</span>
    implementation &#39;org<span class="token punctuation">.</span>jetbrains<span class="token punctuation">.</span>kotlinx<span class="token operator">:</span>kotlinx<span class="token operator">-</span>coroutines<span class="token operator">-</span>core<span class="token operator">:</span><span class="token number">1.5</span><span class="token punctuation">.</span><span class="token number">0</span>&#39;
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>创建协程作用域：使用 <code>CoroutineScope</code> 来创建一个协程的作用域，它将决定协程的生命周期和所运行的上下文。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">val</span> coroutineScope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>定义挂起函数：使用 <code>suspend</code> 关键字来定义挂起函数。挂起函数可以在协程中暂停执行，并在异步操作完成后继续执行。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token comment">// 在这里执行异步操作，例如网络请求或数据库查询</span>
    <span class="token comment">// 使用 suspendCoroutine 或 withContext 等函数进行挂起</span>
    <span class="token comment">// 返回异步操作的结果</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>启动协程：使用协程构建器（例如 <code>launch</code> 或 <code>async</code>）来启动协程。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token comment">// 协程代码块</span>
    <span class="token comment">// 在这里调用挂起函数，例如 fetchData()</span>
    <span class="token comment">// 对结果进行处理</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>使用协程的挂起函数：在协程中可以使用挂起函数来执行异步操作，例如网络请求或数据库查询。挂起函数可以使用 <code>suspendCoroutine</code>、<code>withContext</code>、<code>delay</code> 等函数进行挂起和恢复。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code>coroutineScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 调用挂起函数</span>
    <span class="token comment">// 处理结果</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这只是协程的基本用法，还有许多其他高级特性和函数可以用于处理异常、取消协程、协程间通信等。你可以进一步学习关于协程的概念和用法，例如协程上下文、调度器、异步流等。</p><p>注意：在 Android 中使用协程时，通常需要添加 <code>implementation &#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0&#39;</code> 的依赖，以提供与 Android 主线程的集成支持。</p>`,19),d={href:"https://kotlinlang.org/docs/coroutines",target:"_blank",rel:"noopener noreferrer"},r=a(`<h2 id="globalscope顶层作用域" tabindex="-1"><a class="header-anchor" href="#globalscope顶层作用域" aria-hidden="true">#</a> GlobalScope顶层作用域</h2><p>在 Kotlin 中，创建协程的作用域是必需的，因为它负责协程的生命周期管理和取消。通常情况下，你应该使用 <code>CoroutineScope</code> 来创建协程的作用域，并在作用域内使用协程构建器（如 <code>launch</code>、<code>async</code>）来启动协程。</p><p>然而，有一种特殊情况可以省略创建协程的作用域，直接使用 <code>launch</code>，即在顶层协程中使用 <code>GlobalScope</code>。<code>GlobalScope</code> 是一个全局的协程作用域，它不需要显式地创建，可以直接使用。在顶层协程中使用 <code>GlobalScope</code> 可能会更加方便，但需要谨慎使用，因为它的生命周期不受限制，可能导致资源泄漏或无法预期的行为。</p><p>以下是使用 <code>GlobalScope</code> 创建顶层协程的示例：</p><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">import</span> kotlinx<span class="token punctuation">.</span>coroutines<span class="token punctuation">.</span><span class="token operator">*</span>

<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token comment">// 模拟一个异步操作</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">&quot;Data&quot;</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    GlobalScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span>
        <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 在顶层协程中调用挂起函数</span>
        <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span> <span class="token comment">// 等待协程执行完毕</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们直接在顶层协程中使用 <code>GlobalScope.launch</code> 启动了一个协程，并在其中调用了挂起函数 <code>fetchData()</code>。由于使用了 <code>GlobalScope</code>，我们不需要显式地创建协程的作用域。</p><p>尽管可以使用 <code>GlobalScope</code> 来简化代码，但它不推荐在大多数情况下使用。更好的做法是创建自己的协程作用域，并明确控制协程的生命周期和取消。这样可以更好地管理协程并避免潜在的问题。</p><p>因此，除非特殊情况，通常应该使用 <code>CoroutineScope</code> 来创建协程的作用域，并在作用域内使用协程构建器来启动协程。</p><h2 id="获取挂起函数的返回值" tabindex="-1"><a class="header-anchor" href="#获取挂起函数的返回值" aria-hidden="true">#</a> 获取挂起函数的返回值</h2><p>在协程的作用域外直接获取挂起函数的返回值是不可能的。这是因为挂起函数在执行过程中会挂起当前协程的执行，并在异步操作完成后才会恢复执行。因此，无法立即获得挂起函数的返回值。</p><p>在协程中，可以使用协程构建器提供的一些结构来处理挂起函数的返回值。以下是几种常见的处理方式：</p><ol><li>使用 <code>async</code> 和 <code>await</code>：<code>async</code> 函数可以返回一个 <code>Deferred</code> 对象，该对象代表一个异步计算的结果。可以使用 <code>await</code> 关键字在协程内部等待 <code>Deferred</code> 对象的完成并获取其结果。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string-literal singleline"><span class="token string">&quot;Data&quot;</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token keyword">val</span> deferred <span class="token operator">=</span> async <span class="token punctuation">{</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">val</span> result <span class="token operator">=</span> deferred<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用回调函数：通过将回调函数作为参数传递给挂起函数，在异步操作完成时调用回调函数并传递结果。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Data&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    fetchData <span class="token punctuation">{</span> result <span class="token operator">-&gt;</span>
        <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用 <code>Channel</code>：<code>Channel</code> 是一种用于在协程之间传递数据的通信机制。可以将挂起函数的结果发送到 <code>Channel</code> 中，并在协程外部从 <code>Channel</code> 中接收结果。</li></ol><div class="language-kotlin line-numbers-mode" data-ext="kt"><pre class="language-kotlin"><code><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>channel<span class="token operator">:</span> Channel<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟异步操作</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Data&quot;</span></span><span class="token punctuation">)</span>
    channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span>
    <span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    launch <span class="token punctuation">{</span>
        <span class="token function">fetchData</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>result <span class="token keyword">in</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些是处理挂起函数返回值的常见方法，它们允许在协程内部等待异步操作的完成并获取其结果，或者通过回调函数或通道将结果传递到协程外部。由于协程的异步特性，无法直接在协程外部立即获取挂起函数的返回值。</p><h2 id="runblocking和routinescope的区别" tabindex="-1"><a class="header-anchor" href="#runblocking和routinescope的区别" aria-hidden="true">#</a> runBlocking和RoutineScope的区别</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>runBlocking 与 coroutineScope 可能看起来很类似，因为它们都会等待其协程体以及所有子协程结束。 主要区别在于，runBlocking 方法会阻塞当前线程来等待， 而 coroutineScope 只是挂起，会释放底层线程用于其他用途。 由于存在这点差异，runBlocking 是常规函数，而 coroutineScope 是挂起函数。</p></div><p>常规的阻塞函数（如 <code>Thread.sleep()</code>、<code>BlockingQueue.take()</code> 等）会阻塞当前线程的执行，直到满足某个条件或经过一定的时间。</p><p>而挂起函数（如 <code>delay()</code>、<code>suspendCoroutine()</code> 等）是在协程中使用的特殊函数，它们会挂起当前协程的执行，而不会阻塞线程。挂起函数会将协程的执行暂停，并将控制权还给所在的协程调度器，使得该线程可以去执行其他的协程或任务。当挂起函数所需的条件满足时，协程会被恢复并继续执行。</p><p>主要区别如下：</p><ol><li>阻塞函数会直接阻塞当前线程的执行，而挂起函数会挂起当前协程的执行。</li><li>阻塞函数会阻塞整个线程，使得该线程不能执行其他任务，而挂起函数只会暂停当前协程的执行，允许线程执行其他的协程或任务。</li><li>阻塞函数是常规的 Java 或 Kotlin 函数，不需要特殊的协程支持，而挂起函数必须在协程中使用，通常需要使用协程库（如 Kotlin 的 kotlinx.coroutines）提供的挂起函数或自定义的挂起函数。</li></ol><p>使用挂起函数的主要优势是，它可以实现非阻塞的异步编程模型，使得代码更具可读性和可维护性。通过使用协程，我们可以编写顺序、可组合和易于理解的异步代码，而无需手动管理线程、锁和回调。</p><p>而阻塞函数在某些情况下可能更加简单直观，尤其是在处理一些简单的同步操作时。但是，如果频繁地使用阻塞函数，可能会导致线程资源的浪费和性能问题，因为线程在阻塞期间无法执行其他任务。</p><p>总的来说，挂起函数是协程中用于实现非阻塞异步编程的重要概念，而阻塞函数则是常规的同步编程的一部分。选择使用哪种方式取决于具体的需求和代码设计。</p><h2 id="为什么协程这么麻烦" tabindex="-1"><a class="header-anchor" href="#为什么协程这么麻烦" aria-hidden="true">#</a> 为什么协程这么麻烦</h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>c#中仅仅需要async + await即可拿到返回值，为什么kotlin中要多写这么多代码</p></div><p>在 Kotlin 中，使用协程进行异步操作需要更多的代码，包括使用挂起函数、协程作用域、协程构建器等。这主要是由于 Kotlin 的协程机制与 C# 的异步操作模型有一些不同之处。</p><p>在 C# 中，<code>async</code> 和 <code>await</code> 关键字使得异步编程更加简洁和直观。使用 <code>async</code> 标记一个方法为异步方法，并使用 <code>await</code> 等待异步操作的结果。C# 中的 <code>await</code> 可以在编译时将方法分解为状态机，以便在等待异步操作时让出线程，避免线程阻塞。</p><p>而在 Kotlin 中，协程是基于挂起函数的机制，它提供了更灵活和可控的异步编程方式。协程使用 <code>suspend</code> 修饰函数来标记挂起函数，以指示该函数可以被挂起，并且在协程作用域中使用协程构建器来启动协程。这样的设计使得协程可以更细粒度地控制挂起和恢复，以及协程之间的调度和并发。</p><p>尽管 Kotlin 中使用协程需要更多的代码，但它提供了以下优势：</p><ol><li><p>更细粒度的控制：Kotlin 的协程提供了更细粒度的挂起和恢复控制，可以更好地管理协程的生命周期和取消。</p></li><li><p>可组合性：Kotlin 的协程支持构建复杂的异步操作链，通过协程作用域和协程构建器的组合，可以实现更复杂的异步操作逻辑。</p></li><li><p>异常处理：Kotlin 的协程提供了更灵活的异常处理机制，通过使用 <code>try-catch</code> 块捕获异常，可以更好地处理异步操作中可能发生的异常。</p></li><li><p>更丰富的功能：Kotlin 的协程提供了许多其他功能，如并发原语、超时处理、并发流等，使得异步编程更加丰富和强大。</p></li></ol><p>尽管在 Kotlin 中使用协程需要编写更多的代码，但它提供了更灵活、可控和强大的异步编程模型，可以满足更复杂的异步操作需求。同时，Kotlin 的协程还提供了更好的与其他语言特性（如挂起函数、函数式编程、异常处理）的集成，使得异步编程更加一致和可扩展。</p>`,35);function k(v,m){const e=t("ExternalLinkIcon");return c(),p("div",null,[u,s("p",null,[n("建议查阅 Kotlin 协程的官方文档以获取更详细的信息和示例："),s("a",d,[n("Kotlin 协程官方文档"),l(e)]),n("。")]),r])}const g=o(i,[["render",k],["__file","coroutines.html.vue"]]);export{g as default};
